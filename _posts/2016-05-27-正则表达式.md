---
title: 正则表达式
layout: post
description: 记录文本规则的代码
---

# 正则表达式

> 记录文本规则的代码



## 元字符

### 常用的元字符

| 代码   | 说明             |
| ---- | -------------- |
| .    | 匹配除换行符以外的任意字符  |
| \\w  | 匹配字母或数字或下划线或汉字 |
| \\s  | 匹配任意的空白符       |
| \\d  | 匹配数字           |
| \\b  | 匹配单词的开始或结束     |
| ^    | 匹配字符串的开始       |
| $    | 匹配字符串的结束       |

### 例子

- `\ba\w*\b`匹配以字母a开头的单词
- `\d+` 匹配1个或更多连续的数字
- `\b\w{6}\b` 匹配刚好6个字符的单词
- `^\d{5,12}$`匹配5位到12位数字





## 字符转义

> 使用`\`来取消这些字符的特殊意义

### 例子

- deerchao\.net匹配`deerchao.net`
- `C:\\Windows`匹配C:\Windows。



## 重复

### 常用的限定符

| 代码/语法 | 说明       |
| :---- | -------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？     | 重复零次或一次  |
| {n}   | 重复n次     |
| {n,}  | 重复n次或更多次 |
| {n,m} | 重复n次到m次  |

### 例子

- `Windows\d+`匹配Windows后面跟1个或更多数字
- `^\w+`匹配一行的第一个单词





## 字符类

> 在方括号里列出

### 例子

- `[aeiou]`就匹配任何一个英文元音字母


- `[.?!]`匹配标点符号(.或?或!)
- `[0-9]`代表的含意与`\d`就是完全一致的：一位数字
- `[a-z0-9A-Z_]`也完全等同于`\w`（如果只考虑英文的话）
- `\(?0\d{2}[) -]?\d{8}`匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等





## 分枝条件

> 正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

### 例子

- `0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。
- `\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。
- `\d{5}-\d{4}|\d{5}` & `\d{5}|\d{5}-\d{4}`




## 分组

> 用小括号来指定子表达式(也叫做分组)，然后就可以指定这个子表达式的重复次数了，也可以对子表达式进行其它一些操作。

### 常用分组语法

| 分类   | 代码/语法        | 说明                                       |
| ---- | ------------ | ---------------------------------------- |
| 捕获   | (exp)        | 匹配exp,并捕获文本到自动命名的组里                      |
| 捕获   | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) |
| 捕获   | (?:exp)      | 匹配exp,不捕获匹配的文本，也不给此分组分配组号                |
| 零宽断言 | (?=exp)      | 匹配exp前面的位置                               |
| 零宽断言 | (?<=exp)     | 匹配exp后面的位置                               |
| 零宽断言 | (?!exp)      | 匹配后面跟的不是exp的位置                           |
| 零宽断言 | (?<!exp)     | 匹配前面不是exp的位置                             |
| 注释   | (?#comment)  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读       |

### 例子

- `(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式
  - `\d{1,3}`匹配1到3位的数字
  - `(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次
  - 最后再加上一个一到三位的数字`(\d{1,3})`
- `((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`
  - `2[0-4]\d|25[0-5]|[01]?\d\d?`




## 反义

### 常用的反义代码

| 代码/语法    | 说明                    |
| -------- | --------------------- |
| \W       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S       | 匹配任意不是空白符的字符          |
| \D       | 匹配任意非数字的字符            |
| \B       | 匹配不是单词开头或结束的位置        |
| [^x]     | 匹配除了x以外的任意字符          |
| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |

### 例子

- `\S+`匹配不包含空白符的字符串
- `<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。



## 反向引用

> 使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
>
> 用于重复搜索前面某个分组匹配的文本。例如，`\1`代表分组1匹配的文本。



>也可以自己指定子表达式的组名。
>
>要指定一个子表达式的组名，请使用这样的语法：
>
>> `(?<Word>\w+)`(或者把尖括号换成'也行：`(?'Word'\w+)`),这样就把`\w+`的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。



### 例子

- `\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像go go, 或者kitty kitty
  - `\b(\w+)\b`单词开始处和结束处之间的多于一个的字母或数字
  - 1个或几个空白符`(\s+)`
  - 分组1中捕获的内容（也就是前面匹配的那个单词）`(\1)`



## 零宽断言

- `(?=exp)`也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
- `(?<=exp)`也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
- 假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，用它对1234567890进行查找时结果是234567890。
- 下面这个例子同时使用了这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字(再次强调，不包括这些空白符)。



## 负向零宽断言

> 只匹配一个位置，并不消费任何字符
> - `\b\w*q[^u]\w*\b`匹配包含后面不是字母u的字母q的单词
> - 如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。能匹配整个Iraq fighting
> - 负向零宽断言：`\b\w*q(?!u)\w*\b`

### 例子

- `\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字
- `\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词
- `(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字
- `(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容
  - `(?<=<(\w+)>)`指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)
  - `.*`(任意的字符串)
  - 后缀`(?=<\/\1>)`
    - 后缀里的`\/`，它用到了前面提过的字符转义
    - `\1`则是一个反向引用，引用的正是捕获的第一组
  - 前面的`(\w+)`匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)



## 注释

> 小括号的另一种用途是通过语法(?#comment)来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`

我们可以前面的一个表达式写成这样：

```
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的字母或数字(即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容：前面是一个"/"，后面是先前捕获的标签
)       # 后缀结束
```



## 贪婪与懒惰

### 贪婪匹配

> 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

### 懒惰匹配

> 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的

- `a.*?b`匹配最短的，以a开始，以b结束的字符串
- 如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）

#### 懒惰限定符

| 代码/语法  | 说明               |
| ------ | ---------------- |
| *?     | 重复任意次，但尽可能少重复    |
| +?     | 重复1次或更多次，但尽可能少重复 |
| ??     | 重复0次或1次，但尽可能少重复  |
| {n,m}? | 重复n到m次，但尽可能少重复   |
| {n,}?  | 重复n次以上，但尽可能少重复   |



## 处理选项

### 常用的处理选项

| 名称                            | 说明                                       |      |
| ----------------------------- | ---------------------------------------- | ---- |
| IgnoreCase(忽略大小写)             | 匹配时不区分大小写。                               |      |
| Multiline(多行模式)               | 更改`^`和`$`的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,`$`的精确含意是:匹配\n之前的位置以及字符串结束前的位置.) |      |
| Singleline(单行模式)              | 更改`.`的含义，使它与每一个字符匹配（包括换行符\n）。            |      |
| IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由`#`标记的注释。                |      |
| ExplicitCapture(显式捕获)         | 仅捕获已被显式命名的组。                             |      |



## 平衡组/递归匹配

- `(?'group')` 把捕获的内容命名为group,并压入堆栈(Stack)
- `(?'-group')` 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- `(?(group)yes|no)` 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- `(?!)` 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败



## 其他

| 代码/语法            | 说明                                       |
| ---------------- | ---------------------------------------- |
| \a               | 报警字符(打印它的效果是电脑嘀一声)                       |
| \b               | 通常是单词分界位置，但如果在字符类里使用代表退格                 |
| \t               | 制表符，Tab                                  |
| \r               | 回车                                       |
| \v               | 竖向制表符                                    |
| \f               | 换页符                                      |
| \n               | 换行符                                      |
| \e               | Escape                                   |
| \0nn             | ASCII代码中八进制代码为nn的字符                      |
| \xnn             | ASCII代码中十六进制代码为nn的字符                     |
| \unnnn           | Unicode代码中十六进制代码为nnnn的字符                 |
| \cN              | ASCII控制字符。比如\cC代表Ctrl+C                  |
| \A               | 字符串开头(类似^，但不受处理多行选项的影响)                  |
| \Z               | 字符串结尾或行尾(不受处理多行选项的影响)                    |
| \z               | 字符串结尾(类似$，但不受处理多行选项的影响)                  |
| \G               | 当前搜索的开头                                  |
| \p{name}         | Unicode中命名为name的字符类，例如\p{IsGreek}        |
| (?>exp)          | 贪婪子表达式                                   |
| (?<x>-<y>exp)    | 平衡组                                      |
| (?im-nsx:exp)    | 在子表达式exp中改变处理选项                          |
| (?im-nsx)        | 为表达式后面的部分改变处理选项                          |
| (?(exp)yes\|no)  | 把exp当作零宽正向先行断言，如果在这个位置能匹配，使用yes作为此组的表达式；否则使用no |
| (?(exp)yes)      | 同上，只是使用空表达式作为no                          |
| (?(name)yes\|no) | 如果命名为name的组捕获到了内容，使用yes作为表达式；否则使用no      |
| (?(name)yes)     | 同上，只是使用空表达式作为no                          |
